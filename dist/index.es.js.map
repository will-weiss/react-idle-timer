{"version":3,"file":"index.es.js","sources":["../src/index.js"],"sourcesContent":["/**\n *  ___    _ _     _____ _\n * |_ _|__| | | __|_   _(_)_ __ ___   ___ _ __\n *  | |/ _` | |/ _ \\| | | | '_ ` _ \\ / _ \\ '__|\n *  | | (_| | |  __/| | | | | | | | |  __/ |\n * |___\\__,_|_|\\___||_| |_|_| |_| |_|\\___|_|\n *\n * @name IdleTimer\n * @author Randy Lebeau\n * @private\n */\n\nimport { Component } from 'react'\nimport PropTypes from 'prop-types'\n\n/**\n * Determine if we are in a browser\n * or a server environment\n * @type {Boolean}\n * @private\n */\nconst IS_BROWSER = (typeof window === 'undefined' ? 'undefined' : typeof (window)) === 'object'\n\n/**\n * Default element to listen for events on\n * @type {Object}\n * @private\n */\nconst DEFAULT_ELEMENT = IS_BROWSER ? document : {}\n\n/**\n * The default events to determine activity\n * @type {Array}\n * @private\n */\nconst DEFAULT_EVENTS = [\n  'mousemove',\n  'keydown',\n  'wheel',\n  'DOMMouseScroll',\n  'mouseWheel',\n  'mousedown',\n  'touchstart',\n  'touchmove',\n  'MSPointerDown',\n  'MSPointerMove'\n]\n\n/**\n * Detects when your user is idle\n * @class IdleTimer\n * @private\n */\nexport default class IdleTimer extends Component {\n  /**\n   * Type checks for every property\n   * @type {Object}\n   * @private\n   */\n  static propTypes = {\n    /**\n     * Activity Timeout in milliseconds\n     * default: 1200000\n     * @type {Number}\n     */\n    timeout: PropTypes.number,\n    /**\n     * DOM events to listen to\n     * default: see [default events](https://github.com/SupremeTechnopriest/react-idle-timer#default-events)\n     * @type {Array}\n     */\n    events: PropTypes.arrayOf(PropTypes.string),\n    /**\n     * Function to call when user is idle\n     * default: () => {}\n     * @type {Function}\n     */\n    onIdle: PropTypes.func,\n    /**\n     * Function to call when user becomes active\n     * default: () => {}\n     * @type {Function}\n     */\n    onActive: PropTypes.func,\n    /**\n     * Function to call on user actions\n     * default: () => {}\n     * @type {Function}\n     */\n    onAction: PropTypes.func,\n    /**\n     * Element reference to bind activity listeners to\n     * default: document\n     * @type {Object}\n     */\n    element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n    /**\n     * Start the timer on mount\n     * default: true\n     * @type {Boolean}\n     */\n    startOnMount: PropTypes.bool,\n    /**\n     * Bind events passively\n     * default: true\n     * @type {Boolean}\n     */\n    passive: PropTypes.bool,\n    /**\n     * Capture events\n     * default: true\n     * @type {Boolean}\n     */\n    capture: PropTypes.bool\n  }\n\n  /**\n   * Sets default property values\n   * @type {Object}\n   * @private\n   */\n  static defaultProps = {\n    timeout: 1000 * 60 * 20,\n    element: DEFAULT_ELEMENT,\n    events: DEFAULT_EVENTS,\n    onIdle: () => {},\n    onActive: () => {},\n    onAction: () => {},\n    startOnMount: true,\n    capture: true,\n    passive: true\n  }\n\n  /**\n   * Sets initial component state\n   * @type {Object}\n   * @private\n   */\n  state = {\n    idle: false,\n    oldDate: +new Date(),\n    lastActive: +new Date(),\n    remaining: null,\n    pageX: null,\n    pageY: null\n  }\n\n  /**\n   * The timer instance\n   * @type {Timeout}\n   * @private\n   */\n  tId = null\n\n  /**\n   * Creates an instance of IdleTimer\n   * bind all of our internal events here\n   * for best performance\n   * @param {Object} props\n   * @return {IdleTimer}\n   * @private\n   */\n  constructor (props) {\n    super(props)\n    // If startOnMount is set, idle state defaults to true\n    if (!props.startOnMount) {\n      this.state.idle = true\n    }\n    // Bind all events to component scope, built for speed ðŸš€\n    this.toggleIdleState = this._toggleIdleState.bind(this)\n    this.reset = this._reset.bind(this)\n    this.pause = this._pause.bind(this)\n    this.resume = this._resume.bind(this)\n    this.getRemainingTime = this._getRemainingTime.bind(this)\n    this.getElapsedTime = this._getElapsedTime.bind(this)\n    this.getLastActiveTime = this._getLastActiveTime.bind(this)\n    this.isIdle = this._isIdle.bind(this)\n  }\n\n  /**\n   * Runs when the component mounts\n   * here we bind the events to the\n   * element we want to listen on\n   * @private\n   */\n  componentWillMount () {\n    // Dont bind events if\n    // we are not in a browser\n    if (!IS_BROWSER) return\n    // Otherwise we bind all the events\n    // to the supplied element\n    const { element, events, passive, capture } = this.props\n    events.forEach(e => {\n      element.addEventListener(e, this._handleEvent, {\n        capture,\n        passive\n      })\n    })\n  }\n\n  /**\n   * Runs once the component has mounted\n   * here we handle automatically starting\n   * the idletimer\n   * @private\n   */\n  componentDidMount () {\n    // If startOnMount is enabled\n    // start the timer\n    const { startOnMount } = this.props\n    if (startOnMount) {\n      this.reset()\n    }\n  }\n\n  /**\n   * Called before the component unmounts\n   * here we clear the timer and remove\n   * all the event listeners\n   * @private\n   */\n  componentWillUnmount () {\n    // Clear timeout to prevent delayed state changes\n    clearTimeout(this.tId)\n    // If we are not in a browser\n    // we dont need to unbind events\n    if (!IS_BROWSER) return\n    // Unbind all events\n    const { element, events, passive, capture } = this.props\n    events.forEach(e => {\n      element.removeEventListener(e, this._handleEvent, {\n        capture,\n        passive\n      })\n    })\n  }\n\n  /**\n   * Render children if IdleTimer is used as a wrapper\n   * @return {Component} children\n   * @private\n   */\n  render () {\n    const { children } = this.props\n    return children || null\n  }\n\n  /**\n   * Toggles the idle state and calls\n   * the correct action function\n   * @private\n   */\n  _toggleIdleState (e) {\n    // Toggle the idle state\n    const { idle } = this.state\n    this.setState({\n      idle: !idle\n    })\n\n    // Fire the appropriate action\n    // and pass the event through\n    const { onActive, onIdle } = this.props\n    if (idle) {\n      onActive(e)\n    } else {\n      onIdle(e)\n    }\n  }\n\n  /**\n   * Event handler for supported event types\n   * @param  {Object} e event object\n   * @private\n   */\n  _handleEvent = (e) => {\n    const { remaining, pageX, pageY } = this.state\n    // Already idle, ignore events\n    if (remaining) return\n\n    // Mousemove event\n    if (e.type === 'mousemove') {\n      // If coord are same, it didn't move\n      if (e.pageX === pageX && e.pageY === pageY) {\n        return\n      }\n      // If coord don't exist how could it move\n      if (typeof e.pageX === 'undefined' && typeof e.pageY === 'undefined') {\n        return\n      }\n      // Under 200 ms is hard to do\n      // continuous activity will bypass this\n      // TODO: Cant seem to simulate this event with pageX and pageY for testing\n      // making this block of code unreachable by test suite\n      // opened an issue here https://github.com/Rich-Harris/simulant/issues/19\n      const elapsed = this.getElapsedTime()\n      if (elapsed < 200) {\n        return\n      }\n    }\n\n    // Fire onAction callback with event\n    this.props.onAction(e)\n\n    // Clear any existing timeout\n    clearTimeout(this.tId)\n\n    // If the idle timer is enabled, flip\n    if (this.state.idle) {\n      this._toggleIdleState(e)\n    }\n\n    // Store when the user was last active\n    // and update the mouse coordinates\n    this.setState({\n      lastActive: +new Date(), // store when user was last active\n      pageX: e.pageX, // update mouse coord\n      pageY: e.pageY\n    })\n\n    // Set a new timeout\n    const { timeout } = this.props\n    this.tId = setTimeout(this._toggleIdleState.bind(this), timeout) // set a new timeout\n  }\n\n  /**\n   * Restore initial state and restart timer\n   * @name reset\n   */\n  _reset () {\n    // Clear timeout\n    clearTimeout(this.tId)\n\n    // Reset state\n    this.setState({\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: this.state.oldDate,\n      remaining: null\n    })\n\n    // Set new timeout\n    const { timeout } = this.props\n    this.tId = setTimeout(this._toggleIdleState.bind(this), timeout)\n  }\n\n  /**\n   * Store remaining time and stop timer\n   * @name pause\n   */\n  _pause () {\n    // Timer is already paused\n    const { remaining } = this.state\n    if (remaining !== null) {\n      return\n    }\n\n    // Clear existing timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Define how much is left on the timer\n    this.setState({\n      remaining: this.getRemainingTime()\n    })\n  }\n\n  /**\n   * Resumes a paused timer\n   * @name resume\n   */\n  _resume () {\n    // Timer is not paused\n    const { remaining, idle } = this.state\n    if (remaining === null) {\n      return\n    }\n\n    // Start timer and clear remaining\n    // if we are in the idle state\n    if (!idle) {\n      this.setState({ remaining: null })\n      // Set a new timeout\n      this.tId = setTimeout(this._toggleIdleState.bind(this), remaining)\n    }\n  }\n\n  /**\n   * Time remaining before idle\n   * @name getRemainingTime\n   * @return {Number} Milliseconds remaining\n   */\n  _getRemainingTime () {\n    const { remaining, idle, lastActive } = this.state\n    // If idle there is no time remaining\n    if (idle) {\n      return 0\n    }\n\n    // If timer is in a paused state\n    // just return its remaining time\n    if (remaining !== null) {\n      return remaining\n    }\n\n    // Determine remaining, if negative idle didn't finish flipping, just return 0\n    const { timeout } = this.props\n    let timeLeft = timeout - ((+new Date()) - lastActive)\n    if (timeLeft < 0) {\n      timeLeft = 0\n    }\n    return timeLeft\n  }\n\n  /**\n   * How much time has elapsed\n   * @name getElapsedTime\n   * @return {Timestamp}\n   */\n  _getElapsedTime () {\n    const { oldDate } = this.state\n    return (+new Date()) - oldDate\n  }\n\n  /**\n   * Last time the user was active\n   * @name getLastActiveTime\n   * @return {Timestamp}\n   */\n  _getLastActiveTime () {\n    const { lastActive } = this.state\n    return lastActive\n  }\n\n  /**\n   * Returns wether or not the user is idle\n   * @name isIdle\n   * @return {Boolean}\n   */\n  _isIdle () {\n    const { idle } = this.state\n    return idle\n  }\n}\n"],"names":["IS_BROWSER","window","DEFAULT_ELEMENT","document","DEFAULT_EVENTS","IdleTimer","props","state","Date","tId","_handleEvent","e","_this","remaining","pageX","pageY","type","getElapsedTime","onAction","idle","_toggleIdleState","setState","timeout","setTimeout","bind","startOnMount","toggleIdleState","reset","_reset","pause","_pause","resume","_resume","getRemainingTime","_getRemainingTime","_getElapsedTime","getLastActiveTime","_getLastActiveTime","isIdle","_isIdle","Component","this","element","events","passive","capture","forEach","addEventListener","_this2","removeEventListener","_this3","children","onActive","onIdle","oldDate","lastActive","timeLeft","propTypes","PropTypes","number","arrayOf","string","func","oneOfType","object","bool","defaultProps"],"mappings":"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"}